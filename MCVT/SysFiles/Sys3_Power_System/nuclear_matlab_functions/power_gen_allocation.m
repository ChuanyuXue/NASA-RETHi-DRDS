function [G_solar_power,energy_stored,time_to_discharge,SOC,...
    G_nuclear_power,battery_use_status,total_power_avail,...
    load_shed_status,I_battery]=power_gen_allocation(G_solar_temporary,...
    P_out_solar,V,I_tot,energy_stored,max_storage,time_step, G_nuclear,...
    I_nuclear,SOC_lower_thresh,SOC_upper_thresh, leakage_parameter,...
    trickle_charge_parameter,charge_parameter,I_max_charge,...
    I_max_discharge,sub2_request,sub5_request,sub8_request,...
    battery_power_toggle)
%% Documentation
% Purpose: To allocate the power generation among nuclear power, solar 
%          power, and a battery, as well as tracking the power within the 
%          battery and calculating the time available. The model uses as
%          much power as it can from nuclear, and then supplements that  
%          with solar. For more details see Chapter 2.3 of the 
%          documentation report, henceforth referred to as "report".
% Date Created: 15 March 2021
% Date Last Modified: 10 May 2021
% Modeler Name: Ryan Tomastik (UConn)
% Funding Acknowledgement: Funded by the NASA RETHi Project 
%                          (grant #80NSSC19K1076)

% Version Number: MCVT v4

% Subsystem Connections: This code receives inputs from Subsystems 2, 5,
    % and 8. This code ultimately sends outputs to the same subsystems.

%%% All inputs and outputs to this function are 1 dimensional %%%
% INPUTS %
%   - time_step: Float; the time step used for the model, a constant (s)
%   - P_out_nuclear: Float; The nuclear power generation (W); "P_nuc" in
%   report
%   - P_out_solar: Float; The solar power generation (W); "P_sol" in report
%   - V: Float; The voltage generated by the power system, assumed to be
%   constant (V); "V" in report
%   - I_tot: Float; The power requested by Subsystems 2, 5, and 8 is
%   converted to current and then summed to give I_tot (A); "I_tot"
%   in report
%   - G_nuclear: Float; The gain that P_out_nuclear is multiplied by 
%   based on I_tot to supply as much power as can be (unitless, 
%   0<=G_nuclear<=1); "G_nuc" in report
%   - G_solar_temporary: Float; Used to determine the gain that P_out_solar 
%   is multiplied by based on I_tot (unitless) to supplement the power 
%   supplied by nuclear; "G_temp" in report
%   - I_nuclear: Float; The current produced by the nuclear system 
%   calculated with G_nuclear (A); "I_nom" in report
%   - eng_stored: Float; The power currently stored in the battery (kWh);
%   "E_s" in report
%   - max_storage: Float; The maximum power that can be stored in the
%   battery, a constant (kWh); "E_m" in report
%   - no_battery: Int; Equals 0 if battery is not being used, equals 1 if 
%   battery is being used (unitless)
%   - SOC_lower_thresh: Float; SOC value below which battery is turned off
%   (unitless)
%   - SOC_upper_thresh: Float; SOC value above which battery is used
%   (unitless)
    
% OUTPUTS %
%   - G_solar_power: Float; The gain that P_out_solar is multiplied by 
%   based on G_solar_temporary (unitless, 0<=G_solar_power<=1); "G_sol" in
%   report
%   - eng_stored: Float; The power currently stored in the battery (kWh);
%   "E_s" in report
%   - time_discharge: Float; The time until the battery is fully
%   discharged, is 0 if the battery is not used (hr); "T_d" in report
%   - SOC: Float; The state of charge of the battery (unitless); "SOC" in
%   report
%   - G_nuclear_power: G_nuclear is passed through
%   - no_battery: Int; Equals 0 if battery is not used, equals 1 if battery
%   is used (unitless)

% Function Dependencies: (stored in SysFiles>Subs3>init_callback_functions)
%   - MCVT_Input_File.m

% No Data Dependencies

%% Initial Variable Definitions
persistent warning_flag1 warning_flag2 warning_flag3
if isempty(warning_flag1)||isempty(warning_flag2)||isempty(warning_flag3)
    warning_flag1 = false; warning_flag2 = false; warning_flag3 = false;
end

% these variables must be defined here to avoid a critical error of the
% variables not being defined on all paths
time_to_discharge = 0; 
    % time for battery to fully deplete (hr)
G_nuclear_power = G_nuclear; 
    % G_nuclear is passed through (unitless)
load_shed_status = 0; 
I_battery_for_check = 0;

%% Unit Conversions
kW_to_W = 1000;
W_to_kW = 1/1000;
Ws_to_kWh = 0.001/3600;
s_to_h = 1/3600;

%% If statement determines which of 3 scenarios is occurring
if G_solar_temporary <= 0
%% 1. Nuclear power alone is sufficient; solar and battery are not needed
    G_solar_power = 0; 
    % to prevent solar power from being negative (unitless)
    I_solar = 0; 
    % solar and battery are not needed (A)
    I_battery = 0; 
    % solar and battery are not needed (A)
    SOC = energy_stored/max_storage; 
    % state of charge calculation (unitless)
    if SOC >= SOC_upper_thresh 
    % trickle leak
        battery_use_status = 1;
    % battery is discharging (unitless)
        energy_stored = energy_stored*(1-(s_to_h*leakage_parameter*...
            time_step)); 
    % (kWh) battery is assumed to leak, is not used; leakage_parameter 
    % (in /hr) is how much capacity is lost per hour
        time_to_discharge = (SOC - SOC_lower_thresh)/(leakage_parameter ...
            + eps); 
    % time for battery to deplete below minimum SOC (hr)
    elseif SOC < SOC_lower_thresh 
    % significant charge
        battery_use_status = 0; 
    % battery is charging (unitless)
        I_required = min(I_max_charge, kW_to_W*(max_storage - ...
            energy_stored)*charge_parameter/V); 
    % amount of current sent to the battery (A)
        G_nuclear_power = min(1, G_nuclear_power + I_required/I_nuclear); 
    % adjust G_nuc to send the required current (unitless)
        I_nuclear = G_nuclear_power*I_nuclear; 
    % new nuclear current based on gain (A)
        energy_stored = Ws_to_kWh*((I_nuclear-I_tot)*V)*(time_step)...
            + energy_stored; 
    % charging the battery (kWh)
    else
    % trickle charge
        battery_use_status = 0; 
    % battery is charging (unitless)
        G_nuclear_power = min(1,G_nuclear_power*(1+...
            trickle_charge_parameter)); 
    % will be between 0 and 1 in this scenario (unitless), need extra 
    % current for trickle charging
        I_nuclear = G_nuclear_power*I_nuclear; 
    % new nuclear current based on gain (A)
        energy_stored = Ws_to_kWh*((I_nuclear-I_tot)*V)*(time_step)...
            + energy_stored; 
    % charging the battery (kWh)
    end
elseif G_solar_temporary > 0 && G_solar_temporary < 1
%% 2. Nuclear+Solar power is sufficient; battery is not needed but may leak
    I_solar = P_out_solar/V; 
    % convert solar power to current (A)
    I_battery = 0; 
    % battery not needed (unitless) (but may leak)
    SOC = energy_stored/max_storage; 
    % state of charge calculation (unitless)
    if SOC >= SOC_upper_thresh 
    % trickle leak
        battery_use_status = 1; 
    % battery is discharging (unitless)
        G_solar_power = G_solar_temporary; 
    % gain to be multiplied by the
    % solar power tosupply remaining power (unitless)
        I_solar = G_solar_power*I_solar; 
    % new solar current based on gain (A)
        energy_stored = energy_stored*(1-(s_to_h*leakage_parameter*...
            time_step));
    % battery is assumed to leak (kWh)
        time_to_discharge = (SOC - SOC_lower_thresh)/(leakage_parameter...
            + eps); 
    % time for battery to deplete below minimum SOC (hr)
    elseif SOC < SOC_lower_thresh % significant charge
        battery_use_status = 0; 
    % battery is charging (unitless)
        I_required = min(I_max_charge, kW_to_W*(max_storage - ...
            energy_stored)*charge_parameter/V); 
    % amount of current sent to the battery (A)
        G_solar_power = G_solar_temporary;
        G_solar_power = min(1, G_solar_power + I_required/I_solar);         
    % adjust G_solar_power to send required current (unitless)
        I_solar = G_solar_power*I_solar; 
    % new solar current based on gain (A)
        energy_stored = Ws_to_kWh*(((I_nuclear + I_solar)-I_tot)*V)*...
            (time_step) + energy_stored;
    % charging the battery (kWh)
    else
    % trickle charge
        battery_use_status = 0; 
    % battery is charging (unitless)
        G_solar_power = min(1,G_solar_temporary*(1+...
            trickle_charge_parameter)); 
    % will be between 0 and 1 in this scenario (unitless), need extra 
    % current for trickle charging
        I_solar = G_solar_power*I_solar; 
    % new solar current based on gain (A)
        energy_stored = Ws_to_kWh*(((I_nuclear + I_solar)-I_tot)*V)*...
            (time_step) + energy_stored; 
    % charging the battery (kWh)
    end
else % G_solar_temporary >= 1
%% 3. Nuclear + Solar Power is not sufficient; battery is needed
    battery_use_status = 1; 
    % battery is discharging (unitless)
    G_solar_power = 1;
    % G_solar_power cannot be greater than 1 (unitless)
    I_solar = P_out_solar/V; 
    % convert solar power to current (A)
    I_battery = (I_tot - I_nuclear - I_solar)*battery_power_toggle;
    % remaining current needed to be taken from battery, cannot be negative
    % in this scenario (A)
    if I_battery > I_max_discharge 
    % we cannot send enough power, limited by I_max_discharge
        I_battery_for_check = I_battery; 
    % save for warning check
        I_battery = I_max_discharge; 
    % cannot send more than I_max_discharge (A)
        load_shed_status = 1; 
    % new load schedule is needed
    end
    if warning_flag1 == false
        if I_battery_for_check > I_max_discharge
            fprintf("Warning: power request cannot be met because " + ...
                "the demand is %0.5g kW more than the battery can " + ...
                "discharge. \n Load rescheduling is required. " + ...
                "Currently the schedule is as follows: \n Structural "+...
                "is requesting %0.5g kW \n ECLSS is requesting %0.5g "+...
                "kW \n and Interior is requesting %0.5g kW.",(1/1000)*...
                (I_battery-I_max_discharge)*V,sub2_request,sub5_request,...
                sub8_request);
            warning_flag1 = true;
        end
    end
    energy_stored = energy_stored-Ws_to_kWh*I_battery*V*time_step;
    % battery is discharging (kWh)
    SOC = energy_stored/max_storage; 
    % state of charge calculation (unitless)
    if warning_flag2 == false
        if SOC < SOC_lower_thresh
            fprintf("Warning: the state of charge has dropped below " + ...
                "the threshold of %0.5g. Battery will continue to " + ...
                "discharge.",SOC_lower_thresh);
            warning_flag2 = true;
        end
    end
    if warning_flag3 == false
        if SOC <= eps
            SOC = 0;
            energy_stored = 0;
            disp(" Warning: the battery is shutting down.");
            warning_flag3 = true;
        end
    end
    time_to_discharge = kW_to_W*(SOC - SOC_lower_thresh)*max_storage/...
        (I_battery*V); 
    % time for battery to fully deplete (hr)
end
I_total_supplied = I_battery + I_solar + I_nuclear; % amount of current 
    % that will be sent to other subsystems
total_power_avail = W_to_kW*I_total_supplied*V; % previous current converted  
    % to power
end
